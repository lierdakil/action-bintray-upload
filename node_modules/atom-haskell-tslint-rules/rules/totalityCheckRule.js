"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var utils = require("tsutils");
var ts = require("typescript");
var Lint = require("tslint");
var Rule = (function (_super) {
    __extends(Rule, _super);
    function Rule() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Rule.prototype.applyWithProgram = function (sourceFile, program) {
        return this.applyWithFunction(sourceFile, function (ctx) { return walk(ctx, program.getTypeChecker()); });
    };
    Rule.metadata = {
        ruleName: 'totality-check',
        description: 'Checks if if/switch exhausts type union',
        optionsDescription: 'Not configurable.',
        options: null,
        optionExamples: [true],
        type: 'functionality',
        typescriptOnly: true,
        requiresTypeInfo: true,
    };
    Rule.FAILURE_STRING = 'Switch statement should include a "default" case';
    return Rule;
}(Lint.Rules.TypedRule));
exports.Rule = Rule;
function walk(ctx, tc) {
    function getClauseVal(expr) {
        var type = tc.getTypeAtLocation(expr);
        if (type.flags & ts.TypeFlags.Literal) {
            var lt = type;
            return lt.value;
        }
    }
    function getUnionTypes(e) {
        var type = tc.getTypeAtLocation(e);
        if (type.flags & ts.TypeFlags.Union) {
            var types = type.types;
            if (types.every(function (_a) {
                var flags = _a.flags;
                return 0 !== (flags & ts.TypeFlags.Literal);
            })) {
                return types.map(function (_a) {
                    var value = _a.value;
                    return value;
                });
            }
        }
    }
    function check(node, sourceFile) {
        var switchVariable;
        var cases = everyCase(node, function (expr) {
            if (switchVariable !== undefined) {
                return nodeEquals(expr, switchVariable, sourceFile);
            }
            else {
                switchVariable = expr;
                return true;
            }
        });
        return { cases: cases, switchVariable: switchVariable };
    }
    function everyCase(_a, test) {
        var expression = _a.expression, elseStatement = _a.elseStatement;
        if (elseStatement && !utils.isIfStatement(elseStatement)) {
            return undefined;
        }
        var ec = everyCondition(expression, test);
        if (!ec) {
            return undefined;
        }
        if (!elseStatement) {
            return ec;
        }
        var ec2 = everyCase(elseStatement, test);
        if (!ec2) {
            return undefined;
        }
        return ec.concat(ec2);
    }
    function everyCondition(node, test) {
        if (!utils.isBinaryExpression(node)) {
            return undefined;
        }
        var operatorToken = node.operatorToken, left = node.left, right = node.right;
        switch (operatorToken.kind) {
            case ts.SyntaxKind.BarBarToken: {
                var l = everyCondition(left, test);
                if (!l)
                    return undefined;
                var r = everyCondition(right, test);
                if (!r)
                    return undefined;
                return l.concat(r);
            }
            case ts.SyntaxKind.EqualsEqualsEqualsToken: {
                if (!isSimple(left) || !isSimple(right) || !test(left)) {
                    return undefined;
                }
                var val = getClauseVal(right);
                if (val === undefined)
                    return undefined;
                return [val];
            }
            default:
                return undefined;
        }
    }
    return ts.forEachChild(ctx.sourceFile, function cb(node) {
        if (utils.isSwitchStatement(node)
            && !node.caseBlock.clauses.some(utils.isDefaultClause)) {
            var swnode = node;
            var values = getUnionTypes(swnode.expression);
            if (values) {
                var swvals_1 = swnode.caseBlock.clauses.map(function (_a) {
                    var expression = _a.expression;
                    return getClauseVal(expression);
                });
                var fv = values.filter(function (v) { return swvals_1.indexOf(v) < 0; });
                if (fv.length > 0) {
                    ctx.addFailureAtNode(node, "Match not exhaustive, values not matched: " + fv.join(', '));
                }
            }
        }
        else if (utils.isIfStatement(node)) {
            var _a = check(node, ctx.sourceFile), cases_1 = _a.cases, switchVariable = _a.switchVariable;
            if (cases_1 !== undefined && switchVariable !== undefined) {
                var vv = getUnionTypes(switchVariable);
                if (vv) {
                    var fv = vv.filter(function (v) { return cases_1.indexOf(v) < 0; });
                    if (fv.length > 0) {
                        ctx.addFailureAtNode(node, "Match not exhaustive, values not matched: " + fv.join(', '));
                    }
                }
            }
        }
        return ts.forEachChild(node, cb);
    });
}
function nodeEquals(a, b, sourceFile) {
    return a.getText(sourceFile) === b.getText(sourceFile);
}
function isSimple(node) {
    switch (node.kind) {
        case ts.SyntaxKind.PropertyAccessExpression:
            return isSimple(node.expression);
        case ts.SyntaxKind.PrefixUnaryExpression:
            switch (node.operator) {
                case ts.SyntaxKind.PlusPlusToken:
                case ts.SyntaxKind.MinusMinusToken:
                    return false;
                default:
                    return isSimple(node.operand);
            }
        case ts.SyntaxKind.Identifier:
        case ts.SyntaxKind.NumericLiteral:
        case ts.SyntaxKind.StringLiteral:
        case ts.SyntaxKind.ThisKeyword:
        case ts.SyntaxKind.NoSubstitutionTemplateLiteral:
        case ts.SyntaxKind.TrueKeyword:
        case ts.SyntaxKind.FalseKeyword:
        case ts.SyntaxKind.NullKeyword:
            return true;
        default:
            return false;
    }
}
